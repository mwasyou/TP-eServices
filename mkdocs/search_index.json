{
    "docs": [
        {
            "location": "/", 
            "text": "Travaux Pratiques eServices\n\n\nGL5 - INSAT\n\n\n\n\n\n\nCours Disponible ici: \nhttp://liliasfaxi.wix.com/liliasfaxi/eservices\n\n\nPiazza : \nhttps://piazza.com/class/j3k0yr6cyex4n8\n\n\nRepo Github :  \nhttps://github.com/INSATunisia\n\n\n\n\nOverview\n\n\nL'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants:\n\n\n\n\nL'architecture orient\u00e9e services (SOA: Service-Oriented Architecture)\n\n\nLa composition de services: orchestration et chor\u00e9graphie\n\n\nLes bus de services (ESB: Enterprise Service Bus)\n\n\nLes Microservices\n\n\nLe API Management\n\n\nL'architecture orient\u00e9e web (WOA: Web-Oriented Architecture)\n\n\n\n\nCe cours comporte cinq s\u00e9ances de travaux pratiques:\n\n\n\n\nTP1: Manipulation des services SOAP et REST avec Talend\n\n\nTP2: Orchestration des services avec Activiti\n\n\nTP3: Mise en place d'un ESB avec Talend ESB\n\n\nTP4: Microservices\n\n\nTP5: API Management avec Anypoint", 
            "title": "Home"
        }, 
        {
            "location": "/#travaux-pratiques-eservices", 
            "text": "", 
            "title": "Travaux Pratiques eServices"
        }, 
        {
            "location": "/#gl5-insat", 
            "text": "Cours Disponible ici:  http://liliasfaxi.wix.com/liliasfaxi/eservices  Piazza :  https://piazza.com/class/j3k0yr6cyex4n8  Repo Github :   https://github.com/INSATunisia", 
            "title": "GL5 - INSAT"
        }, 
        {
            "location": "/#overview", 
            "text": "L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants:   L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture)  La composition de services: orchestration et chor\u00e9graphie  Les bus de services (ESB: Enterprise Service Bus)  Les Microservices  Le API Management  L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture)   Ce cours comporte cinq s\u00e9ances de travaux pratiques:   TP1: Manipulation des services SOAP et REST avec Talend  TP2: Orchestration des services avec Activiti  TP3: Mise en place d'un ESB avec Talend ESB  TP4: Microservices  TP5: API Management avec Anypoint", 
            "title": "Overview"
        }, 
        {
            "location": "/tp1/", 
            "text": "TP1 - Services Web REST et SOAP avec Talend\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\nCr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.\n\n\nOutils et Versions\n\n\n\n\nTalend Open Studio for ESB\n Version: 6.3.0\n\n\nJava\n Version 1.8.0_121\n\n\nMySQL\n Version 14.14 Distrib 5.6.34\n\n\nSOAPUI\n Version 5.3.0\n\n\n\n\nTalend ESB\n\n\nTalend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services\nweb s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes.\nTalend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9\nApache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache\net a fait plusieurs contributions aux projets Apache.\nTalend fournit:\n\n\n\n\nUn courtier de messages \u00e0 haute performance.\n\n\nDes options de d\u00e9ploiement flexibles\n\n\nDes outils de d\u00e9veloppement pour Eclipse\n\n\nUne interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications\n\n\nSupport pour les services web SOAP et REST\n\n\nLa m\u00e9diation et le routage\n\n\nSupport pour le failover, le monitoring et la s\u00e9curit\u00e9\n\n\n\n\nL\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi.\nL\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox\ncomme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les\ndiff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.\n\n\nTalend Open Studio for ESB\n\n\nTalend Open Studio for ESB (TOS-ESB) fournit une interface graphique de\nd\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des\napplications REST, des services de donn\u00e9es et des routes de messages.\nLe d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs\nrepr\u00e9sent\u00e9s dans cette figure:\n\n\n\n\n\n\nLe bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des\ndonn\u00e9es, des services ou des applications\n\n\nLes blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend\nd\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et\nd\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est\npossible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez\nbasculer gr\u00e2ce \u00e0 Talend Service Locator.\n\n\nLe bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les\ninformations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services.\n\n\n\n\nL\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit:\n\n\n\n\n\n\n\n\n\n\nComposant\n\n\nFonctionnalit\u00e9\n\n\n\n\n\n\n\n\n\n\n\n\nLe traditionnel \nRepository\n contenant vos Jobs, services, fichiers, routes\u2026\n\n\n\n\n\n\n\n\nLa fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes\n\n\n\n\n\n\n\n\nLa fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026\n\n\n\n\n\n\n\n\nLa palette des composants \u00e0 utiliser\n\n\n\n\n\n\n\n\nLes onglets pour le choix de la perspective \u00e0 utiliser\n\n\n\n\n\n\n\n\nService Web SOAP : Helloworld\n\n\nNous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des\nservices web avec les outils Talend ESB. Nous allons donc commencer avec le\ntraditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix.\nDans toute cette partie, nous nous trouverons dans la perspective Integration.\n\n\nCr\u00e9er le service SOAP\n\n\nPour cr\u00e9er un nouveau service de type SOAP:\n\n\n\n\nClic-droit sur \nServices\n de votre Repository, et choisir \nCreate Service\n. Appeler le\nservice \nHelloWorldService\n. Cliquer sur Suivant.\n\n\nOn vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer.\n\n\nUn service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est\ncr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.\n\n\n\n\n\n\nConfigurer le service SOAP\n\n\nPour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord:\n\n\n\n\nImporter le WSDL de votre service dans votre repository. Pour cela, clic droit sur\n\nHelloWorldService\n, et choisir \nImporter les sch\u00e9mas WSDL\n. Vous retrouverez votre\nWSDL dans la partie \nMetadonn\u00e9es -\n Fichier XML\n.\n\n\nCr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration \nHelloWorldServiceOperation\n (sous Services) et choisir \nAssign Job\n.\n\n\nModifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le \ntLogRow\n nous permettra\nd\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au\nconsommateur):\n\n\n\n\n\n\n\n\n\n\nConfigurer votre tXMLMap pour que le \nin\n de la requ\u00eate soit transmise au \nout\n de la\nr\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela:\n\n\n\n\nDouble clic sur votre XML Map.\n\n\nClic-droit sur \npayload\n de l\u2019entr\u00e9e, et cliquer sur \nImport from Repository\n.\n\n\nChoisir le \nHelloWorldServiceOperationRequest\n correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9.\n\n\nRefaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant \nHelloWorldServiceOperationResponse\n.\n\n\nRelier le \nin\n de la requ\u00eate avec le \nout\n de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse)\n\n\nModifier l\u2019expression du \nout\n en ajoutant la cha\u00eene \n\u201cHello \u201c\n avant la valeur \nin\n de l\u2019entr\u00e9e.\n\n\nLe r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\nSauvegarder et quitter.\n\n\n\n\n\n\n\n\nLancer votre Job (cela permettra de publier votre service web sur le port 8090).\nV\u00e9rifier que votre fichier WSDL existe bien.\n\n\n\n\n\n\nTester le service SOAP\n\n\nIl est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 \nSOAPUI\n.\n\n\n\n\nLancer SOAPUI\n\n\nCliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale\n\n\nDonner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit:\n\n\n\n\n\n\n\n\nDouble cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le \n?\n par un nom de votre choix.\n\n\nCliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:\n\n\n\n\n\n\nConsommateur du WebService SOAP\n\n\nNous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela:\n\n\n\n\nCr\u00e9er un nouveau Job, que vous appellerez \nHelloWorldServiceConsumer\n.\n\n\nConcevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante:\n\n\n\n\n\n\n\n\n\n\nVoici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 :\n\n\n\n\ntFixedFlowInput\n : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service\n\n\ntXMLMap\n : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service\n\n\ntESBConsumer\n : consommateur du service\n\n\ntLogRow\n: afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a)\n\n\n\n\n\n\n\n\nConfigurer votre composant \ntFixedFlowInput\n. Pour cela:\n\n\n\n\nCliquer sur \nModifier le sch\u00e9ma\n et ajouter une colonne appel\u00e9e \nNom\n de type \nString\n.\n\n\nUtiliser une \nInline Table\n pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d.\n\n\n\n\n\n\n\n\nConfigurer votre \ntESBConsumer\n en lui donnant comme WSDL celui du service que\nvous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090.\n\n\n\n\nConfigurer votre \ntXMLMap\n pour que la variable \nNom\n soit associ\u00e9e au \nin\n de votre\nservice.\n\n\nEx\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:\n\n\n\n\n\n\nService Web REST : Interrogation d'une base de donn\u00e9es\n\n\nNous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.\n\n\nCr\u00e9ation de la base de donn\u00e9es\n\n\nNous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e \neservices-tp1\n avec une table, que nous appellerons \nuser\n. Cette table contient les champs \nid\n, \nfirstname\n et \nlastname\n. Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es.\n\n\nElle devra ressembler \u00e0 ce qui suit:\n\n\n\n\nAjout de la connexion \u00e0 la base avec Talend\n\n\nPour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes:\n\n\n\n\nDans les M\u00e9tadonn\u00e9es, sous \nConnexions aux bases de donn\u00e9es\n, clic-droit, puis choisir: \nCr\u00e9er une connexion\n.\n\n\nConfigurer votre connexion. Voici un exemple:\n\n\n\n\n\n\n\n\nUne fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -\n Connexions... -\n \n et choisir: \nR\u00e9cup\u00e9rer le sch\u00e9ma\n.\n\n\nS\u00e9lectionner la table \nuser\n, et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.\n\n\n\n\nCr\u00e9ation du service REST\n\n\nNous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera \nDBService\n, puis glisser les composants suivants:\n\n\n\n\ntRestRequest\n : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler\n\n\nuser\n : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous \nSch\u00e9mas des tables\n, glisser la table \nuser\n vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet.\n\n\n\n\n\n\nRemarque\n\n\nJe choisis \ntMySQLInput\n car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le \nInput\n).\n\n\n\n\n\n\ntFlowToIterate\n : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales.\n\n\ntXMLMap\n : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate.\n\n\ntRestResponse\n : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate.\n\n\ntLogRow\n : Pour le log, bien s\u00fbr.\n\n\n\n\nLe job aura l'allure suivante:\n\n\n\n\nConfiguration du service REST\n\n\nNous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI:\n\nhttp://localhost:8088/users?from=1\nto=3\n, le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.  \n\n\nConfiguration de tRestRequest\n\n\ntRestRequest devra \u00eatre configur\u00e9 comme suit:\n\n\n\n\nLa valeur de \nEndpoint URL\n devra \u00eatre: \nhttp://localhost:8088/users\n\n\nSi vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 \ngetUsers\n, vous devriez le retrouver dans la case \nREST API Mapping\n. Sinon, cr\u00e9ez-le.\n\n\nGarder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON).\n\n\nEn cliquant sur \ngetUsers\n, un bouton avec trois petits points appara\u00eet. Cliquez dessus.\n\n\n\n\nAjouter les deux colonnes \nfrom\n et \nto\n repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que:\n\n\n\n\nLeur type soit \nint\n\n\nLeurs valeurs par d\u00e9faut soient respectivement 1 et 3.\n\n\n\n\n\n\nRemarque\n\n\nCes valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres.\n\n\n\n\n\n\nLeur commentaire ait la valeur: \nquery\n\n\n\n\n\n\nRemarque\n\n\nCela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.\n\n\n\n\n\n\n\n\nConfiguration de user\n\n\nPuisque le composant \nuser\n a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires.\n\n\nIl suffira dans notre cas de:\n\n\n\n\nCliquer sur \nGuess Schema\n  pour charger le sch\u00e9ma de la base.\n\n\nChanger la requ\u00eate pour qu'elle soit comme suit:\n\n\n\n\nSELECT * FROM `user` where id\n=\n+\nglobalMap\n.\nget\n(\ngetUsers.from\n)\n+\n\n                      \n and id\n=\n+\nglobalMap\n.\nget\n(\ngetUsers.to\n)\n\n\n\n\n\n\n\nRemarque\n\n\nglobalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres.\n\n\n\n\nConfiguration de tXMLMap\n\n\nCliquer deux fois sur la \ntXMLMap\n pour la configurer.\n\n\n\n\nDans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e \nbody\n dont le type est \nDocument\n.\n\n\nCette colonne contient un \u00e9l\u00e9ment \nroot\n. Renommer cet \u00e9l\u00e9ment pour \nusers\n.\n\n\nAjouter un sous-\u00e9l\u00e9ment \u00e0 \nusers\n appel\u00e9 \nuser\n.\n\n\nD\u00e9finir cet \u00e9l\u00e9ment comme \nloop Element\n.\n\n\nGlisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le \nuser\n. Cr\u00e9ez-le comme attribut du noeud cible.\n\n\nDe m\u00eame pour le \nfirstname\n et \nlastname\n, qui seront, eux, des sous-\u00e9l\u00e9ments du noeud \nuser\n.\n\n\nDans la colonne de droite, cliquer sur la petite clef \u00e0 molette (\n). Mettre la valeur de \"All in one\" \u00e0 \ntrue\n. Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux.\n\n\n\n\nLa configuration finale sera donc comme suit:\n\n\n\n\n\n\nIndication\n\n\nLa configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante:\n\n\nusers\n\n  \nuser\n \nid=\n1\n\n    \nfirstname\n flen \n/firstname\n\n    \nlastname\n fouleni \n/lastname\n\n  \n/user\n\n  \nuser\n \nid=\n2\n\n    \nfirstname\n flena \n/firstname\n\n    \nlastname\n foulenia \n/lastname\n\n  \n/user\n\n\nusers\n\n\n\n\n\n\n\nLes autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur \nEx\u00e9cuter\n.\n\n\nTester le Service\n\n\nDans un navigateur\n\n\nPour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix.\n\n\nPar exemple, la requ\u00eate suivante : \nhttp://localhost:8088/users?from=2\nto=4\n donnera:\n\n\n  \nusers\n\n      \nuser\n \nid=\n2\n\n          \nfirstname\nSouad\n/firstname\n\n          \nlastname\nMezghenni\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n3\n\n          \nfirstname\nMourad\n/firstname\n\n          \nlastname\nLahwel\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n4\n\n          \nfirstname\nMonia\n/firstname\n\n          \nlastname\nLandolsi\n/lastname\n\n      \n/user\n\n  \n/users\n\n\n\nSi aucun param\u00e8tre n'est indiqu\u00e9: \nhttp://localhost:8088/users\n cela donnera:\n\n\n  \nusers\n\n      \nuser\n \nid=\n1\n\n          \nfirstname\nAhmed\n/firstname\n\n          \nlastname\nRamzi\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n2\n\n          \nfirstname\nSouad\n/firstname\n\n          \nlastname\nMezghenni\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n3\n\n          \nfirstname\nMourad\n/firstname\n\n          \nlastname\nLahwel\n/lastname\n\n      \n/user\n\n  \n/users\n\n\n\n\n\nAvec SOAPUI\n\n\nTester le service SOAP\n\n\nIl est possible de tester votre service REST avec \nSOAPUI\n.\n\n\n\n\nLancer SOAPUI\n\n\nCliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale\n\n\nEntrer l'URI que vous d\u00e9sirez tester: \nhttp://localhost:8088/users?from=2\nto=4\n\n\nLa fen\u00eatre suivante devrait appara\u00eetre:\n\n\n\n\n\n\n\n\nCliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:\n\n\n\n\n\n\nConsommateur du WebService REST\n\n\nPour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant:\n\n\n\n\nConfigurer le \ntRestClient\n comme suit:\n\n\n\n\nEx\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:", 
            "title": "TP1"
        }, 
        {
            "location": "/tp1/#tp1-services-web-rest-et-soap-avec-talend", 
            "text": "", 
            "title": "TP1 - Services Web REST et SOAP avec Talend"
        }, 
        {
            "location": "/tp1/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp1/#objectifs-du-tp", 
            "text": "Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp1/#outils-et-versions", 
            "text": "Talend Open Studio for ESB  Version: 6.3.0  Java  Version 1.8.0_121  MySQL  Version 14.14 Distrib 5.6.34  SOAPUI  Version 5.3.0", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp1/#talend-esb", 
            "text": "Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services\nweb s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes.\nTalend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9\nApache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache\net a fait plusieurs contributions aux projets Apache.\nTalend fournit:   Un courtier de messages \u00e0 haute performance.  Des options de d\u00e9ploiement flexibles  Des outils de d\u00e9veloppement pour Eclipse  Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications  Support pour les services web SOAP et REST  La m\u00e9diation et le routage  Support pour le failover, le monitoring et la s\u00e9curit\u00e9   L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi.\nL\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox\ncomme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les\ndiff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.", 
            "title": "Talend ESB"
        }, 
        {
            "location": "/tp1/#talend-open-studio-for-esb", 
            "text": "Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de\nd\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des\napplications REST, des services de donn\u00e9es et des routes de messages.\nLe d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs\nrepr\u00e9sent\u00e9s dans cette figure:    Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des\ndonn\u00e9es, des services ou des applications  Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend\nd\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et\nd\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est\npossible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez\nbasculer gr\u00e2ce \u00e0 Talend Service Locator.  Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les\ninformations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services.   L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit:      Composant  Fonctionnalit\u00e9       Le traditionnel  Repository  contenant vos Jobs, services, fichiers, routes\u2026     La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes     La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026     La palette des composants \u00e0 utiliser     Les onglets pour le choix de la perspective \u00e0 utiliser", 
            "title": "Talend Open Studio for ESB"
        }, 
        {
            "location": "/tp1/#service-web-soap-helloworld", 
            "text": "Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des\nservices web avec les outils Talend ESB. Nous allons donc commencer avec le\ntraditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix.\nDans toute cette partie, nous nous trouverons dans la perspective Integration.", 
            "title": "Service Web SOAP : Helloworld"
        }, 
        {
            "location": "/tp1/#creer-le-service-soap", 
            "text": "Pour cr\u00e9er un nouveau service de type SOAP:   Clic-droit sur  Services  de votre Repository, et choisir  Create Service . Appeler le\nservice  HelloWorldService . Cliquer sur Suivant.  On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer.  Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est\ncr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.", 
            "title": "Cr\u00e9er le service SOAP"
        }, 
        {
            "location": "/tp1/#configurer-le-service-soap", 
            "text": "Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord:   Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur HelloWorldService , et choisir  Importer les sch\u00e9mas WSDL . Vous retrouverez votre\nWSDL dans la partie  Metadonn\u00e9es -  Fichier XML .  Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration  HelloWorldServiceOperation  (sous Services) et choisir  Assign Job .  Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le  tLogRow  nous permettra\nd\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au\nconsommateur):      Configurer votre tXMLMap pour que le  in  de la requ\u00eate soit transmise au  out  de la\nr\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela:   Double clic sur votre XML Map.  Clic-droit sur  payload  de l\u2019entr\u00e9e, et cliquer sur  Import from Repository .  Choisir le  HelloWorldServiceOperationRequest  correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9.  Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant  HelloWorldServiceOperationResponse .  Relier le  in  de la requ\u00eate avec le  out  de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse)  Modifier l\u2019expression du  out  en ajoutant la cha\u00eene  \u201cHello \u201c  avant la valeur  in  de l\u2019entr\u00e9e.  Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit:     Sauvegarder et quitter.     Lancer votre Job (cela permettra de publier votre service web sur le port 8090).\nV\u00e9rifier que votre fichier WSDL existe bien.", 
            "title": "Configurer le service SOAP"
        }, 
        {
            "location": "/tp1/#tester-le-service-soap", 
            "text": "Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9  SOAPUI .   Lancer SOAPUI  Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale  Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit:     Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le  ?  par un nom de votre choix.  Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:", 
            "title": "Tester le service SOAP"
        }, 
        {
            "location": "/tp1/#consommateur-du-webservice-soap", 
            "text": "Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela:   Cr\u00e9er un nouveau Job, que vous appellerez  HelloWorldServiceConsumer .  Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante:      Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 :   tFixedFlowInput  : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service  tXMLMap  : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service  tESBConsumer  : consommateur du service  tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a)     Configurer votre composant  tFixedFlowInput . Pour cela:   Cliquer sur  Modifier le sch\u00e9ma  et ajouter une colonne appel\u00e9e  Nom  de type  String .  Utiliser une  Inline Table  pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d.     Configurer votre  tESBConsumer  en lui donnant comme WSDL celui du service que\nvous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090.   Configurer votre  tXMLMap  pour que la variable  Nom  soit associ\u00e9e au  in  de votre\nservice.  Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:", 
            "title": "Consommateur du WebService SOAP"
        }, 
        {
            "location": "/tp1/#service-web-rest-interrogation-dune-base-de-donnees", 
            "text": "Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.", 
            "title": "Service Web REST : Interrogation d'une base de donn\u00e9es"
        }, 
        {
            "location": "/tp1/#creation-de-la-base-de-donnees", 
            "text": "Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e  eservices-tp1  avec une table, que nous appellerons  user . Cette table contient les champs  id ,  firstname  et  lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es.  Elle devra ressembler \u00e0 ce qui suit:", 
            "title": "Cr\u00e9ation de la base de donn\u00e9es"
        }, 
        {
            "location": "/tp1/#ajout-de-la-connexion-a-la-base-avec-talend", 
            "text": "Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes:   Dans les M\u00e9tadonn\u00e9es, sous  Connexions aux bases de donn\u00e9es , clic-droit, puis choisir:  Cr\u00e9er une connexion .  Configurer votre connexion. Voici un exemple:     Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -  Connexions... -    et choisir:  R\u00e9cup\u00e9rer le sch\u00e9ma .  S\u00e9lectionner la table  user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.", 
            "title": "Ajout de la connexion \u00e0 la base avec Talend"
        }, 
        {
            "location": "/tp1/#creation-du-service-rest", 
            "text": "Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera  DBService , puis glisser les composants suivants:   tRestRequest  : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler  user  : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous  Sch\u00e9mas des tables , glisser la table  user  vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet.    Remarque  Je choisis  tMySQLInput  car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le  Input ).    tFlowToIterate  : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales.  tXMLMap  : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate.  tRestResponse  : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate.  tLogRow  : Pour le log, bien s\u00fbr.   Le job aura l'allure suivante:", 
            "title": "Cr\u00e9ation du service REST"
        }, 
        {
            "location": "/tp1/#configuration-du-service-rest", 
            "text": "Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI: http://localhost:8088/users?from=1 to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.", 
            "title": "Configuration du service REST"
        }, 
        {
            "location": "/tp1/#configuration-de-trestrequest", 
            "text": "tRestRequest devra \u00eatre configur\u00e9 comme suit:   La valeur de  Endpoint URL  devra \u00eatre:  http://localhost:8088/users  Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9  getUsers , vous devriez le retrouver dans la case  REST API Mapping . Sinon, cr\u00e9ez-le.  Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON).  En cliquant sur  getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus.   Ajouter les deux colonnes  from  et  to  repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que:   Leur type soit  int  Leurs valeurs par d\u00e9faut soient respectivement 1 et 3.    Remarque  Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres.    Leur commentaire ait la valeur:  query    Remarque  Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.", 
            "title": "Configuration de tRestRequest"
        }, 
        {
            "location": "/tp1/#configuration-de-user", 
            "text": "Puisque le composant  user  a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires.  Il suffira dans notre cas de:   Cliquer sur  Guess Schema   pour charger le sch\u00e9ma de la base.  Changer la requ\u00eate pour qu'elle soit comme suit:   SELECT * FROM `user` where id = + globalMap . get ( getUsers.from ) + \n                        and id = + globalMap . get ( getUsers.to )    Remarque  globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres.", 
            "title": "Configuration de user"
        }, 
        {
            "location": "/tp1/#configuration-de-txmlmap", 
            "text": "Cliquer deux fois sur la  tXMLMap  pour la configurer.   Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e  body  dont le type est  Document .  Cette colonne contient un \u00e9l\u00e9ment  root . Renommer cet \u00e9l\u00e9ment pour  users .  Ajouter un sous-\u00e9l\u00e9ment \u00e0  users  appel\u00e9  user .  D\u00e9finir cet \u00e9l\u00e9ment comme  loop Element .  Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le  user . Cr\u00e9ez-le comme attribut du noeud cible.  De m\u00eame pour le  firstname  et  lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud  user .  Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0  true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux.   La configuration finale sera donc comme suit:    Indication  La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante:  users \n   user   id= 1 \n     firstname  flen  /firstname \n     lastname  fouleni  /lastname \n   /user \n   user   id= 2 \n     firstname  flena  /firstname \n     lastname  foulenia  /lastname \n   /user  users    Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur  Ex\u00e9cuter .", 
            "title": "Configuration de tXMLMap"
        }, 
        {
            "location": "/tp1/#tester-le-service", 
            "text": "", 
            "title": "Tester le Service"
        }, 
        {
            "location": "/tp1/#dans-un-navigateur", 
            "text": "Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix.  Par exemple, la requ\u00eate suivante :  http://localhost:8088/users?from=2 to=4  donnera:     users \n       user   id= 2 \n           firstname Souad /firstname \n           lastname Mezghenni /lastname \n       /user \n       user   id= 3 \n           firstname Mourad /firstname \n           lastname Lahwel /lastname \n       /user \n       user   id= 4 \n           firstname Monia /firstname \n           lastname Landolsi /lastname \n       /user \n   /users  \nSi aucun param\u00e8tre n'est indiqu\u00e9:  http://localhost:8088/users  cela donnera:     users \n       user   id= 1 \n           firstname Ahmed /firstname \n           lastname Ramzi /lastname \n       /user \n       user   id= 2 \n           firstname Souad /firstname \n           lastname Mezghenni /lastname \n       /user \n       user   id= 3 \n           firstname Mourad /firstname \n           lastname Lahwel /lastname \n       /user \n   /users", 
            "title": "Dans un navigateur"
        }, 
        {
            "location": "/tp1/#avec-soapui", 
            "text": "", 
            "title": "Avec SOAPUI"
        }, 
        {
            "location": "/tp1/#tester-le-service-soap_1", 
            "text": "Il est possible de tester votre service REST avec  SOAPUI .   Lancer SOAPUI  Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale  Entrer l'URI que vous d\u00e9sirez tester:  http://localhost:8088/users?from=2 to=4  La fen\u00eatre suivante devrait appara\u00eetre:     Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:", 
            "title": "Tester le service SOAP"
        }, 
        {
            "location": "/tp1/#consommateur-du-webservice-rest", 
            "text": "Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant:   Configurer le  tRestClient  comme suit:   Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:", 
            "title": "Consommateur du WebService REST"
        }, 
        {
            "location": "/tp2/", 
            "text": "TP2 - Orchestration de Services avec Camunda\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\nCr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.\n\n\nOutils et Versions\n\n\n\n\nCamunda\n Version: 7.7.0\n\n\nJava\n Version 1.8.0_121 (7+ needed).\n\n\nIntelliJ IDEA\n Version Ultimate 2016.1 (ou tout autre IDE de votre choix)\n\n\nCamunda Modeler\n Version 1.10.0\n\n\n\n\nCamunda \n\n\nCamunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support \nBPMN\n pour l'automatisation des processus, \nCMMN\n pour le Case Management, et \nDMN\n pour le Business Decision Management.\n\n\nBPMN 2.0 \n\n\nBPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group (\nOMG\n) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations.\n\n\nDans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier.\n\n\nCette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.\n\n\nInstallation\n\n\nPour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes:\n\n\n\n\nT\u00e9l\u00e9charger \nCamunda\n (Distribution Tomcat), \nIntelliJ IDEA\n et \nCamunda Modeler\n.\n\n\nD\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter \nstart-camunda.sh\n (pour les syst\u00e8mes Unix-based) ou \nstart-camunda.bat\n (pour les syst\u00e8mes Windows).\n\n\nOuvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9.\n\n\nLancer le Camunda Modeler.\n\n\n\n\nPremier Projet Camunda BPN: Helloworld\n\n\nCr\u00e9ation du Projet et D\u00e9pendances\n\n\nVous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus.\n\n\n\n\nOuvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype).\n\n\n\n\nVous pouvez choisir les param\u00e8tres suivants:\n\n\n\n\nGroup Id: \ntn.insat.eservices.tp2\n\n\nArtifact Id: \nHelloworld\n\n\nProject Name: \nHelloworldCamunda\n\n\n\n\n\n\n\n\nDans le fichier \npom.xml\n, indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier \nwar\n. Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version:\n\n\n\n\n\n\npackaging\nwar\n/packaging\n\n\n\n\n\n\n\nAjouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier \npom.xml\n\n\n\n\ndependencyManagement\n\n    \ndependencies\n\n      \ndependency\n\n        \ngroupId\norg.camunda.bpm\n/groupId\n\n        \nartifactId\ncamunda-bom\n/artifactId\n\n        \nversion\n7.7.0\n/version\n\n        \nscope\nimport\n/scope\n\n        \ntype\npom\n/type\n\n      \n/dependency\n\n    \n/dependencies\n\n  \n/dependencyManagement\n\n\n  \ndependencies\n\n    \ndependency\n\n      \ngroupId\norg.camunda.bpm\n/groupId\n\n      \nartifactId\ncamunda-engine\n/artifactId\n\n      \nscope\nprovided\n/scope\n\n    \n/dependency\n\n\n    \ndependency\n\n      \ngroupId\njavax.servlet\n/groupId\n\n      \nartifactId\njavax.servlet-api\n/artifactId\n\n      \nversion\n3.0.1\n/version\n\n      \nscope\nprovided\n/scope\n\n    \n/dependency\n\n  \n/dependencies\n\n\n  \nbuild\n\n    \nplugins\n\n      \nplugin\n\n        \ngroupId\norg.apache.maven.plugins\n/groupId\n\n        \nartifactId\nmaven-war-plugin\n/artifactId\n\n        \nversion\n2.3\n/version\n\n        \nconfiguration\n\n          \nfailOnMissingWebXml\nfalse\n/failOnMissingWebXml\n\n        \n/configuration\n\n      \n/plugin\n\n    \n/plugins\n\n  \n/build\n\n\n\n\n\n\n\nFaire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez \nmaven-install\n par exemple, et vous \u00e9crirez dans la partie \nCommand Line\n : \ninstall\n, comme suit:\n\n\n\n\n\n\n\n\nLancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s.\n\n\n\n\nCr\u00e9ation de la classe principale pour le processus\n\n\nLa prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda.\n\n\npackage\n \ntn.insat.eservices.tp2.helloworld\n;\n\n\n\nimport\n \norg.camunda.bpm.application.ProcessApplication\n;\n\n\nimport\n \norg.camunda.bpm.application.impl.ServletProcessApplication\n;\n\n\n\n@ProcessApplication\n(\nHelloworld App\n)\n\n\npublic\n \nclass\n \nHelloworldApplication\n \nextends\n \nServletProcessApplication\n \n{\n\n    \n// empty implementation\n\n\n}\n\n\n\n\n\nAjouter ensuite le fichier \nprocesses.xml\n sous le r\u00e9pertoire \nsrc/main/resources/META-INF\n. Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\n\nprocess-application\n\n        \nxmlns=\nhttp://www.camunda.org/schema/1.0/ProcessApplication\n\n        \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \nprocess-archive\n \nname=\nhelloworld\n\n        \nprocess-engine\ndefault\n/process-engine\n\n        \nproperties\n\n            \nproperty\n \nname=\nisDeleteUponUndeploy\nfalse\n/property\n\n            \nproperty\n \nname=\nisScanForProcessDefinitions\ntrue\n/property\n\n        \n/properties\n\n    \n/process-archive\n\n\n\n/process-application\n\n\n\n\n\nA partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.\n\n\nMod\u00e9lisation d'un processus BPMN 2.0\n\n\nLa mod\u00e9lisation du processus se fera gr\u00e2ce au \nCamunda Modeler\n. Pour cela:\n\n\n\n\nD\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur \nFile \n New File \n BPMN Diagram\n.\n\n\n\n\n\n\n\n\nDouble-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons \nDis Bonjour\n.\n\n\nCliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 \nAjouter Bonjour\n.\n\n\n\n\n\n\n\n\nCette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel \nBonjour \nnom>!\n. Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir \nUser Task\n.\n\n\n\n\n\n\n\n\nRajouter une t\u00e2che de fin au processus.\n\n\n\n\nNous obtenons pour finir le diagramme suivant:\n\n\n\n\nConfiguration du processus\n\n\n\n\nPour configurer la t\u00e2che utilisateur \nAjouter Bonjour\n, cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ \nAssignee\n, ins\u00e9rer \njohn\n. John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les.\n\n\nPour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants:\n\n\nId: \nhelloworld\n\n\nName: \nHelloworld\n\n\nExecutable: \ntrue\n\n\n\n\n\n\n\n\nVous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\nSauvegarder le diagramme sous le r\u00e9pertoire \nsrc/main/resources\n du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez \nhelloworld.bpmn\n\n\n\n\nD\u00e9ploiement du processus\n\n\n\n\n\n\nConfigurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ:\n\n\n\n\nAller au menu \nFile \n Project Structure...\n\n\nCliquer sur \nArtifacts\n.\n\n\nD\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: \nWeb Application: Archive\n\n\nD\u00e9finir comme Output Directory le r\u00e9pertoire \nwebapps\n, se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire \n$CAMUNDA_HOME/server/apache-tomcat-\nversion>/webapps\n.\n\n\nEn bas de la fen\u00eatre, vous trouverez un bouton \nCreate Manifest\n. Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement.\n\n\nVous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\n\n\n\n\n\n\nFaire un \nmake\n du projet. Pour cela, aller au menu \nBuild \n Make Project\n ou cliquer sur \n. Normalement, un nouveau fichier \nhelloworld-1.0-SNAPSHOT.war\n sera cr\u00e9\u00e9 dans le r\u00e9pertoire \nwebapps\n du serveur.\n\n\n\n\nPour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous \n$CAMUNDA_HOME/server/apache-tomcat-\nversion>/logs\n et ouvrir le fichier \ncatalina.out\n.\n\n\n\n\nTip\n\n\nLe meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper \ntail -f catalina.out\n.\n\n\n\n\nLe fichier devra contenir les lignes suivantes:\n\n\n\n\nV\u00e9rification du d\u00e9ploiement avec Cockpit\n\n\nCamunda offre l'outil \nCockpit\n pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: \nhttp://localhost:8080/camunda/app/cockpit\n. Identifiez-vous comme administrateur en tapant les credentials: \ndemo/demo\n. Cliquer sur le nombre sous \nProcess Definitions\n (cela devra \u00eatre \n2\n dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat \nchecked\n.\n\n\n\n\nD\u00e9marrage du processus\n\n\n\n\nAller au \nCamunda Tasklist\n (\nhttp://localhost:8080/camunda/app/tasklist\n), puis lancer le processus en cliquant sur le bouton \nStart Process\n (en haut \u00e0 droite).\n\n\nCliquer sur votre processus \nHelloworld\n.\n\n\nAjouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable \nnom\n de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur \nAdd a variable\n et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien \n ):\n\n\n\n\n\n\n\n\nEn rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat \nRunning\n.\n\n\n\n\nConfiguration des permissions\n\n\nPour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus \nHelloworld\n, il faudra lui rajouter les autorisations. Pour cela:\n\n\n\n\nAller \u00e0 \nCamunda Admin\n (\nhttp://localhost:8080/camunda/app/admin/default/#/authorization?resource=0\n).\n\n\nAjouter une nouvelle autorisation dans la partie \nProcess Definition\n, pour permettre \u00e0 John de manipuler la d\u00e9finition du processus \nHelloworld\n.\n\n\n\n\n\n\n\n\nDans la partie \nProcess Instance\n, ajouter la permission de cr\u00e9er une instance de processus \u00e0 John.\n\n\n\n\n\n\n\n\nVous authentifier comme \u00e9tant John, en utilisant (\njohn/john\n), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.\n\n\n\n\n\n\nCr\u00e9ation d'un formulaire personnalis\u00e9\n\n\nPour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service,  suivre les \u00e9tapes suivantes:\n\n\n\n\nRevenir vers IntelliJ, et cr\u00e9er un fichier \ndis-bonjour.html\n sous le r\u00e9pertoire \nsrc/main/webapp/forms\n. Ajouter le contenu suivant:\n\n\n\n\nform\n \nname\n=\ndisBonjour\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nnom\nNom\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nnom\n\n               \nname\n=\nnom\n \n/\n\n    \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\n\nOuvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation \nForms\n  et ins\u00e9rer \nembedded:app:forms/dis-bonjour.html\n dans le champ \nKey\n. Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application.\n\n\nSauvegarder, et rafra\u00eechir le projet dans IntelliJ.\n\n\nDe m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera \nbonjour.html\n.\n\n\n\n\nform\n \nname\n=\nbonjour\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nsalutation\nSalutation\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nsalutation\n\n               \nname\n=\nsalutation\n \n/\n\n    \n/\ndiv\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nnom\nNom\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nnom\n\n               \nname\n=\nnom\n\n               \nreadonly\n=\ntrue\n \n/\n\n    \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\n\nAffecter ce formulaire \u00e0 la t\u00e2che \nAjouter Bonjour\n de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment.\n\n\nSauvegarder tout et re-d\u00e9ployer le projet.\n\n\nLancer maintenant le processus. Saisir votre nom dans la rubrique \nNom\n.\n\n\n\n\n\n\n\n\nIdentifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire:\n\n\n\n\n\n\nPour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un \nService Task\n.\n\n\nAjout d'un Service Task Java\n\n\nPour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes:\n\n\n\n\nUtiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette \n , s\u00e9lectionner l'option \nService Task\n. Appeler le service \nDire Bonjour\n. Vous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\n\n\nAjouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e \nProcessRequestDelegate\n qui impl\u00e9mente l'interface \nJavaDelegate\n, comme suit:\n\n\n\n\npackage\n \ntn.insat.eservices.tp2.helloworld\n;\n\n\n\nimport\n \njava.util.logging.Logger\n;\n\n\nimport\n \norg.camunda.bpm.engine.delegate.DelegateExecution\n;\n\n\nimport\n \norg.camunda.bpm.engine.delegate.JavaDelegate\n;\n\n\n\npublic\n \nclass\n \nProcessRequestDelegate\n \nimplements\n \nJavaDelegate\n \n{\n\n\n    \nprivate\n \nfinal\n \nstatic\n \nLogger\n \nLOGGER\n \n=\n \nLogger\n.\ngetLogger\n(\nHello-Greetings\n);\n\n\n    \npublic\n \nvoid\n \nexecute\n(\nDelegateExecution\n \nexecution\n)\n \nthrows\n \nException\n \n{\n\n        \nLOGGER\n.\ninfo\n(\nHey! \n \n+\n \nexecution\n.\ngetVariable\n(\nsalutation\n)\n\n                    \n+\n \n \n \n+\n \nexecution\n.\ngetVariable\n(\nnom\n)\n \n+\n \n!\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\nUtiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: \ntn.insat.eservices.tp2.helloworld.ProcessRequestDelegate\n.\n\n\nD\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:\n\n\n\n\n\n\nAppel d'un Service Web REST\n\n\nGr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour.\n\n\n\n\nCommencer par ajuster le formulaire \nbonjour.html\n, en lui ajoutant un autre champs de texte: \nville\n apr\u00e8s le champs \nnom\n.\n\n\nRevenir dans le Modeler, et ajouter un Service Task, qu'on appellera \nConsulter M\u00e9t\u00e9o\n, entre \nAjouter Bonjour\n  et \nDire Bonjour\n.\n\n\nDans ce service, indiquer que le type d'impl\u00e9mentation est \nConnector\n, et vous d\u00e9placer vers l'onglet \nConnector\n pour le configurer.\n\n\n\n\nDonner les param\u00e8tres suivants \u00e0 votre connecteur;\n\n\n\n\nId\n: \nhttp-connector\n\n\nInput\n: Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web \nOpenWeatherMap\n. Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs \nville\n.\n\n\n\n\n\n\n\n\n\n\nNom\n\n\nType\n\n\nValeur\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nScript / JavaScript / Inline Script\n\n\nvar ville=execution.getVariable(\nville\n); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266\nq='+ville;\n\n\n\n\n\n\nmethod\n\n\nText\n\n\nGET\n\n\n\n\n\n\nheaders\n\n\nMap\n\n\nkey: accept, value:application/json -       key:content-type, value:application/json\n\n\n\n\n\n\n\n\n\n\nOutput\n: Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\n{\n\n  \ncoord\n:\n \n{\n\n    \nlon\n:\n \n10.17\n,\n\n    \nlat\n:\n \n36.82\n\n  \n},\n\n  \nweather\n:\n \n[\n\n    \n{\n\n      \nid\n:\n \n801\n,\n\n      \nmain\n:\n \nClouds\n,\n\n      \ndescription\n:\n \nfew clouds\n,\n\n      \nicon\n:\n \n02d\n\n    \n}\n\n  \n],\n\n  \nbase\n:\n \nstations\n,\n\n  \nmain\n:\n \n{\n\n    \ntemp\n:\n \n299.87\n,\n\n    \npressure\n:\n \n1018\n,\n\n    \nhumidity\n:\n \n39\n,\n\n    \ntemp_min\n:\n \n299.15\n,\n\n    \ntemp_max\n:\n \n301.15\n\n  \n},\n\n  \nvisibility\n:\n \n10000\n,\n\n  \nwind\n:\n \n{\n\n    \nspeed\n:\n \n3.6\n,\n\n    \ndeg\n:\n \n40\n\n  \n},\n\n  \nclouds\n:\n \n{\n\n    \nall\n:\n \n20\n\n  \n},\n\n  \ndt\n:\n \n1506864600\n,\n\n  \nsys\n:\n \n{\n\n    \ntype\n:\n \n1\n,\n\n    \nid\n:\n \n6318\n,\n\n    \nmessage\n:\n \n0.0039\n,\n\n    \ncountry\n:\n \nTN\n,\n\n    \nsunrise\n:\n \n1506834907\n,\n\n    \nsunset\n:\n \n1506877308\n\n  \n},\n\n  \nid\n:\n \n2464470\n,\n\n  \nname\n:\n \nTunis\n,\n\n  \ncod\n:\n \n200\n\n\n}\n\n\n\n\n\nSi l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment \nmain\n puis \u00e0 son fils \ntemp\n. L'output de notre service aura donc la forme suivante:\n\n\n\n\n\n\n\n\nNom\n\n\nType\n\n\nValeur\n\n\n\n\n\n\n\n\n\n\nWsResponse\n\n\nScript / JavaScript / Inline Script\n\n\nS(response).prop(\nmain\n).prop(\ntemp\n).numberValue();\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nToujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application!\n\n\n\n\n\n\nMaintenant, ajouter le code d'exploitation de ce service dans la classe \nProcessRequestDelegate\n, pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate:\n\n\n\n\npublic\n \nclass\n \nProcessRequestDelegate\n \nimplements\n \nJavaDelegate\n \n{\n\n\n    \nprivate\n \nfinal\n \nstatic\n \nLogger\n \nLOGGER\n \n=\n \nLogger\n.\ngetLogger\n(\nHello-Greetings\n);\n\n\n    \npublic\n \nvoid\n \nexecute\n(\nDelegateExecution\n \nexecution\n)\n \nthrows\n \nException\n \n{\n\n        \nLOGGER\n.\ninfo\n(\nHey! \n \n+\n \nexecution\n.\ngetVariable\n(\nsalutation\n)\n \n+\n \n \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nnom\n)\n\n                \n+\n \n! La temp\u00e9rature aujourd\nhui \u00e0 \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nville\n)\n\n                \n+\n \n est de \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nWsResponse\n)+\n!\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\n\n\nTout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant:\n\n\n\n\n\n\nL'utilisateur demo saisit son nom:\n\n\n\n\n\n\n\nL'utilisateur john rajoute la salutation et la ville:\n\n\n\n\n\n\n\nLe processus affiche ce r\u00e9sultat sur le log:\n\n\n\n\n\n\n\n\n\n\n\n\n\nTAF\n\n\nVous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Farenheit. Chercher un service web qui fasse la conversion du \u00baF vers le \u00baC, puis appelez-le avant de faire l'affichage.\n\n\n\n\nHomework\n\n\nVous \u00eates manager d'une entreprise, dont vous choisirez le nom et le m\u00e9tier.Vous d\u00e9sirez r\u00e9aliser une application pour faciliter son processus de recrutement. C'est \u00e0 vous de choisir le degr\u00e9 de complexit\u00e9 et les sp\u00e9cificit\u00e9s m\u00e9tier du processus, \u00e0 partir du moment qu'il respecte ces conditions:\n\n\n\n\nVous devez d\u00e9finir au moins trois types d'acteurs.\n\n\nVous devez impl\u00e9menter votre processus avec Camunda.\n\n\nVous devez utiliser un service web REST ou SOAP impl\u00e9ment\u00e9 avec Talend.\n\n\nVous devez utiliser une base de donn\u00e9es.\n\n\n\n\nPour la s\u00e9ance de TP prochaine, vous devez me pr\u00e9senter un processus \nqui marche\n, en m'expliquant son fonctionnement et les choix m\u00e9tier que vous avez fait.", 
            "title": "TP2"
        }, 
        {
            "location": "/tp2/#tp2-orchestration-de-services-avec-camunda", 
            "text": "", 
            "title": "TP2 - Orchestration de Services avec Camunda"
        }, 
        {
            "location": "/tp2/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp2/#objectifs-du-tp", 
            "text": "Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp2/#outils-et-versions", 
            "text": "Camunda  Version: 7.7.0  Java  Version 1.8.0_121 (7+ needed).  IntelliJ IDEA  Version Ultimate 2016.1 (ou tout autre IDE de votre choix)  Camunda Modeler  Version 1.10.0", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp2/#camunda", 
            "text": "Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support  BPMN  pour l'automatisation des processus,  CMMN  pour le Case Management, et  DMN  pour le Business Decision Management.", 
            "title": "Camunda"
        }, 
        {
            "location": "/tp2/#bpmn-20", 
            "text": "BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations.  Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier.  Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.", 
            "title": "BPMN 2.0"
        }, 
        {
            "location": "/tp2/#installation", 
            "text": "Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes:   T\u00e9l\u00e9charger  Camunda  (Distribution Tomcat),  IntelliJ IDEA  et  Camunda Modeler .  D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter  start-camunda.sh  (pour les syst\u00e8mes Unix-based) ou  start-camunda.bat  (pour les syst\u00e8mes Windows).  Ouvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9.  Lancer le Camunda Modeler.", 
            "title": "Installation"
        }, 
        {
            "location": "/tp2/#premier-projet-camunda-bpn-helloworld", 
            "text": "", 
            "title": "Premier Projet Camunda BPN: Helloworld"
        }, 
        {
            "location": "/tp2/#creation-du-projet-et-dependances", 
            "text": "Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus.   Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype).   Vous pouvez choisir les param\u00e8tres suivants:   Group Id:  tn.insat.eservices.tp2  Artifact Id:  Helloworld  Project Name:  HelloworldCamunda     Dans le fichier  pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier  war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version:    packaging war /packaging    Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier  pom.xml   dependencyManagement \n     dependencies \n       dependency \n         groupId org.camunda.bpm /groupId \n         artifactId camunda-bom /artifactId \n         version 7.7.0 /version \n         scope import /scope \n         type pom /type \n       /dependency \n     /dependencies \n   /dependencyManagement \n\n   dependencies \n     dependency \n       groupId org.camunda.bpm /groupId \n       artifactId camunda-engine /artifactId \n       scope provided /scope \n     /dependency \n\n     dependency \n       groupId javax.servlet /groupId \n       artifactId javax.servlet-api /artifactId \n       version 3.0.1 /version \n       scope provided /scope \n     /dependency \n   /dependencies \n\n   build \n     plugins \n       plugin \n         groupId org.apache.maven.plugins /groupId \n         artifactId maven-war-plugin /artifactId \n         version 2.3 /version \n         configuration \n           failOnMissingWebXml false /failOnMissingWebXml \n         /configuration \n       /plugin \n     /plugins \n   /build    Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez  maven-install  par exemple, et vous \u00e9crirez dans la partie  Command Line  :  install , comme suit:     Lancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s.", 
            "title": "Cr\u00e9ation du Projet et D\u00e9pendances"
        }, 
        {
            "location": "/tp2/#creation-de-la-classe-principale-pour-le-processus", 
            "text": "La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda.  package   tn.insat.eservices.tp2.helloworld ;  import   org.camunda.bpm.application.ProcessApplication ;  import   org.camunda.bpm.application.impl.ServletProcessApplication ;  @ProcessApplication ( Helloworld App )  public   class   HelloworldApplication   extends   ServletProcessApplication   { \n     // empty implementation  }   Ajouter ensuite le fichier  processes.xml  sous le r\u00e9pertoire  src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus.  ?xml version= 1.0  encoding= UTF-8  ?  process-application \n         xmlns= http://www.camunda.org/schema/1.0/ProcessApplication \n         xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     process-archive   name= helloworld \n         process-engine default /process-engine \n         properties \n             property   name= isDeleteUponUndeploy false /property \n             property   name= isScanForProcessDefinitions true /property \n         /properties \n     /process-archive  /process-application   A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.", 
            "title": "Cr\u00e9ation de la classe principale pour le processus"
        }, 
        {
            "location": "/tp2/#modelisation-dun-processus-bpmn-20", 
            "text": "La mod\u00e9lisation du processus se fera gr\u00e2ce au  Camunda Modeler . Pour cela:   D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur  File   New File   BPMN Diagram .     Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons  Dis Bonjour .  Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9  Ajouter Bonjour .     Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel  Bonjour  nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir  User Task .     Rajouter une t\u00e2che de fin au processus.   Nous obtenons pour finir le diagramme suivant:", 
            "title": "Mod\u00e9lisation d'un processus BPMN 2.0"
        }, 
        {
            "location": "/tp2/#configuration-du-processus", 
            "text": "Pour configurer la t\u00e2che utilisateur  Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ  Assignee , ins\u00e9rer  john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les.  Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants:  Id:  helloworld  Name:  Helloworld  Executable:  true     Vous obtiendrez le r\u00e9sultat suivant:    Sauvegarder le diagramme sous le r\u00e9pertoire  src/main/resources  du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez  helloworld.bpmn", 
            "title": "Configuration du processus"
        }, 
        {
            "location": "/tp2/#deploiement-du-processus", 
            "text": "Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ:   Aller au menu  File   Project Structure...  Cliquer sur  Artifacts .  D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer:  Web Application: Archive  D\u00e9finir comme Output Directory le r\u00e9pertoire  webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire  $CAMUNDA_HOME/server/apache-tomcat- version>/webapps .  En bas de la fen\u00eatre, vous trouverez un bouton  Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement.  Vous obtiendrez le r\u00e9sultat suivant:       Faire un  make  du projet. Pour cela, aller au menu  Build   Make Project  ou cliquer sur  . Normalement, un nouveau fichier  helloworld-1.0-SNAPSHOT.war  sera cr\u00e9\u00e9 dans le r\u00e9pertoire  webapps  du serveur.   Pour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous  $CAMUNDA_HOME/server/apache-tomcat- version>/logs  et ouvrir le fichier  catalina.out .   Tip  Le meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper  tail -f catalina.out .   Le fichier devra contenir les lignes suivantes:", 
            "title": "D\u00e9ploiement du processus"
        }, 
        {
            "location": "/tp2/#verification-du-deploiement-avec-cockpit", 
            "text": "Camunda offre l'outil  Cockpit  pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant:  http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials:  demo/demo . Cliquer sur le nombre sous  Process Definitions  (cela devra \u00eatre  2  dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat  checked .", 
            "title": "V\u00e9rification du d\u00e9ploiement avec Cockpit"
        }, 
        {
            "location": "/tp2/#demarrage-du-processus", 
            "text": "Aller au  Camunda Tasklist  ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton  Start Process  (en haut \u00e0 droite).  Cliquer sur votre processus  Helloworld .  Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable  nom  de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur  Add a variable  et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien   ):     En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat  Running .", 
            "title": "D\u00e9marrage du processus"
        }, 
        {
            "location": "/tp2/#configuration-des-permissions", 
            "text": "Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus  Helloworld , il faudra lui rajouter les autorisations. Pour cela:   Aller \u00e0  Camunda Admin  ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ).  Ajouter une nouvelle autorisation dans la partie  Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus  Helloworld .     Dans la partie  Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John.     Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.", 
            "title": "Configuration des permissions"
        }, 
        {
            "location": "/tp2/#creation-dun-formulaire-personnalise", 
            "text": "Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service,  suivre les \u00e9tapes suivantes:   Revenir vers IntelliJ, et cr\u00e9er un fichier  dis-bonjour.html  sous le r\u00e9pertoire  src/main/webapp/forms . Ajouter le contenu suivant:   form   name = disBonjour \n     div   class = form-group \n         label   for = nom Nom / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = nom \n                name = nom   / \n     / div  / form    Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation  Forms   et ins\u00e9rer  embedded:app:forms/dis-bonjour.html  dans le champ  Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application.  Sauvegarder, et rafra\u00eechir le projet dans IntelliJ.  De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera  bonjour.html .   form   name = bonjour \n     div   class = form-group \n         label   for = salutation Salutation / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = salutation \n                name = salutation   / \n     / div \n     div   class = form-group \n         label   for = nom Nom / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = nom \n                name = nom \n                readonly = true   / \n     / div  / form    Affecter ce formulaire \u00e0 la t\u00e2che  Ajouter Bonjour  de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment.  Sauvegarder tout et re-d\u00e9ployer le projet.  Lancer maintenant le processus. Saisir votre nom dans la rubrique  Nom .     Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire:    Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un  Service Task .", 
            "title": "Cr\u00e9ation d'un formulaire personnalis\u00e9"
        }, 
        {
            "location": "/tp2/#ajout-dun-service-task-java", 
            "text": "Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes:   Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette   , s\u00e9lectionner l'option  Service Task . Appeler le service  Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant:     Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e  ProcessRequestDelegate  qui impl\u00e9mente l'interface  JavaDelegate , comme suit:   package   tn.insat.eservices.tp2.helloworld ;  import   java.util.logging.Logger ;  import   org.camunda.bpm.engine.delegate.DelegateExecution ;  import   org.camunda.bpm.engine.delegate.JavaDelegate ;  public   class   ProcessRequestDelegate   implements   JavaDelegate   { \n\n     private   final   static   Logger   LOGGER   =   Logger . getLogger ( Hello-Greetings ); \n\n     public   void   execute ( DelegateExecution   execution )   throws   Exception   { \n         LOGGER . info ( Hey!    +   execution . getVariable ( salutation ) \n                     +       +   execution . getVariable ( nom )   +   ! ); \n     }  }    Utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class:  tn.insat.eservices.tp2.helloworld.ProcessRequestDelegate .  D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:", 
            "title": "Ajout d'un Service Task Java"
        }, 
        {
            "location": "/tp2/#appel-dun-service-web-rest", 
            "text": "Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour.   Commencer par ajuster le formulaire  bonjour.html , en lui ajoutant un autre champs de texte:  ville  apr\u00e8s le champs  nom .  Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera  Consulter M\u00e9t\u00e9o , entre  Ajouter Bonjour   et  Dire Bonjour .  Dans ce service, indiquer que le type d'impl\u00e9mentation est  Connector , et vous d\u00e9placer vers l'onglet  Connector  pour le configurer.   Donner les param\u00e8tres suivants \u00e0 votre connecteur;   Id :  http-connector  Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web  OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs  ville .      Nom  Type  Valeur      url  Script / JavaScript / Inline Script  var ville=execution.getVariable( ville ); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266 q='+ville;    method  Text  GET    headers  Map  key: accept, value:application/json -       key:content-type, value:application/json      Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit:     { \n   coord :   { \n     lon :   10.17 , \n     lat :   36.82 \n   }, \n   weather :   [ \n     { \n       id :   801 , \n       main :   Clouds , \n       description :   few clouds , \n       icon :   02d \n     } \n   ], \n   base :   stations , \n   main :   { \n     temp :   299.87 , \n     pressure :   1018 , \n     humidity :   39 , \n     temp_min :   299.15 , \n     temp_max :   301.15 \n   }, \n   visibility :   10000 , \n   wind :   { \n     speed :   3.6 , \n     deg :   40 \n   }, \n   clouds :   { \n     all :   20 \n   }, \n   dt :   1506864600 , \n   sys :   { \n     type :   1 , \n     id :   6318 , \n     message :   0.0039 , \n     country :   TN , \n     sunrise :   1506834907 , \n     sunset :   1506877308 \n   }, \n   id :   2464470 , \n   name :   Tunis , \n   cod :   200  }   Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment  main  puis \u00e0 son fils  temp . L'output de notre service aura donc la forme suivante:     Nom  Type  Valeur      WsResponse  Script / JavaScript / Inline Script  S(response).prop( main ).prop( temp ).numberValue();      Tip  Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application!    Maintenant, ajouter le code d'exploitation de ce service dans la classe  ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate:   public   class   ProcessRequestDelegate   implements   JavaDelegate   { \n\n     private   final   static   Logger   LOGGER   =   Logger . getLogger ( Hello-Greetings ); \n\n     public   void   execute ( DelegateExecution   execution )   throws   Exception   { \n         LOGGER . info ( Hey!    +   execution . getVariable ( salutation )   +     \n                 +   execution . getVariable ( nom ) \n                 +   ! La temp\u00e9rature aujourd hui \u00e0  \n                 +   execution . getVariable ( ville ) \n                 +    est de  \n                 +   execution . getVariable ( WsResponse )+ ! ); \n     }  }     Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant:    L'utilisateur demo saisit son nom:    L'utilisateur john rajoute la salutation et la ville:    Le processus affiche ce r\u00e9sultat sur le log:       TAF  Vous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Farenheit. Chercher un service web qui fasse la conversion du \u00baF vers le \u00baC, puis appelez-le avant de faire l'affichage.", 
            "title": "Appel d'un Service Web REST"
        }, 
        {
            "location": "/tp2/#homework", 
            "text": "Vous \u00eates manager d'une entreprise, dont vous choisirez le nom et le m\u00e9tier.Vous d\u00e9sirez r\u00e9aliser une application pour faciliter son processus de recrutement. C'est \u00e0 vous de choisir le degr\u00e9 de complexit\u00e9 et les sp\u00e9cificit\u00e9s m\u00e9tier du processus, \u00e0 partir du moment qu'il respecte ces conditions:   Vous devez d\u00e9finir au moins trois types d'acteurs.  Vous devez impl\u00e9menter votre processus avec Camunda.  Vous devez utiliser un service web REST ou SOAP impl\u00e9ment\u00e9 avec Talend.  Vous devez utiliser une base de donn\u00e9es.   Pour la s\u00e9ance de TP prochaine, vous devez me pr\u00e9senter un processus  qui marche , en m'expliquant son fonctionnement et les choix m\u00e9tier que vous avez fait.", 
            "title": "Homework"
        }, 
        {
            "location": "/tp3/", 
            "text": "TP3 - Mise en Place d\u2019un ESB avec Talend ESB\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\n\n\nRoutage, m\u00e9diation et transformation avec Talend ESB.\n\n\nGestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.\n\n\n\n\nOutils et Versions\n\n\n\n\nTalend Open Studio for ESB\n Version: 6.3.0\n\n\nJava\n Version 1.8.0_121\n\n\n\n\nConfiguration et Utilisation de l'ESB Talend\n\n\nLancement de deux instances de l'ESB Talend\n\n\nPour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire:\n\n\n\n\nAller dans le r\u00e9pertoire \nrep_install_talend>/Runtime_ESBSE\n\n\nCopier le r\u00e9pertoire \ncontainer\n et le renommer en \nalternate-container\n.\n\n\n\n\nNous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans \nalternate-container\n) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela:\n\n\n\n\nLancer l\u2019ESB\n : dans le r\u00e9pertoire \nalternate-container\n que vous venez de cr\u00e9er, aller vers \nbin\n et ex\u00e9cuter \ntrun.bash\n (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire \nalternate-container/bin\n et  lancer dans un terminal la commande \n./trun\n. La fen\u00eatre suivante devrait s\u2019afficher:\n\n\n\n\n\n\n\n\nAttention\n\n\nLe premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante.\n\n\n\n\n\n\nConfigurer l'ESB\n : dans l\u2019invite de commande affich\u00e9e, taper:\n\n\n\n\n  \nsource\n scripts/configureC1.sh\n\n\n\n\n\n\nUn affichage tel que le suivant va appara\u00eetre:\n\n\n\n\n\n\nVous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh.\n\n\n\n\nArr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau.\n\n\nLancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.\n\n\n\n\nPublier votre Service dans l'ESB et le Tester\n\n\nRevenir au service web SOAP \nHelloWorldService\n que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur \nTalend Open Studio\n sur le projet \nHelloworld\n, et suivre les \u00e9tapes suivantes:\n\n\n\n\nFaire un clic-droit sur le service \nHelloWorldService\n et choisir \nExporter le service\n. Choisir comme r\u00e9pertoire de destination le dossier \ndeploy\n se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB).\n\n\nD\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9.\n\n\nV\u00e9rifier que vos services sont actifs:\n\n\nen tapant \nlist\n dans vos deux instances d\u2019ESB\n\n\nen affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090.\n\n\n\n\n\n\n\n\nPour tester votre service web:\n\n\n\n\nDans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040\n\n\nLancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB.\n\n\n\n\nV\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:\n\n\n\n\nCr\u00e9ation des Routes\n\n\nLes routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.\n\n\nPremi\u00e8re Route: Filtrage des Messages\n\n\n\n\nCr\u00e9er une nouvelle route en cliquant-droit sur \nRoutes -\n Cr\u00e9er une Route\n. Nous allons l\u2019appeler FiltrageRoute.\n\n\nD\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\n\n\nLes composants utilis\u00e9s sont:\n\n\n\n\ncCXF\n : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS.\n\n\nMessageRouter\n\u00a0: route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es.\n\n\n\n\n\n\n\n\nConfigurer la condition \nwhen\n, en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est :\n\n\n\n\n\n\n    \n${bodyAs(String)} contains \nAlice\n\n\n\n  Cela veut dire que, si le corps du message contient \nAlice\n, la requ\u00eate sera rout\u00e9e vers le composant \ncCXF_2\n.\n\n\n\n\n\n\nConfigurer le composant cCXF_1:\n\n\n\n\nAdresse: \nhttp://localhost:8042/services/HelloWorldService\n  \n\n\nWSDL: \nhttp://localhost:8040/services/HelloWorldService?WSDL\n.\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\nRemarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB.\n\n\n\n\n\n\nConfigurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants.\n\n\nLancer la route pour la tester. La console devra afficher \nconnected\n.\n\n\n\n\nPour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous?\n\n\nD\u00e9ploiement des Routes sur l'ESB\n\n\nDans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes:\n\n\n\n\nFaites un clic-droit sur votre route et s\u00e9lectionner: \nBuild Route\n (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9).\n\n\nChoisir le r\u00e9pertoire deploy du conteneur de votre choix.\n\n\nTester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur.\n\n\n\n\n\n\nAttention\n\n\nVous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.\n\n\n\n\nDeuxi\u00e8me Route : Filtrage et Modification de Messages\n\n\nDans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela:\n\n\n\n\nDans Talend Studio, dupliquer votre route \nFiltrageRoute\n et la nommer \nModificationRoute\n.\n\n\nIns\u00e9rer un composant \ncSetBody\n (permettant de modifier le corps du message re\u00e7u) puis un composant \ncProcessor\n (permettant  de remanier rapidement du code dans la route) entre le \ncMessageRouter\n et le \ncCXF_3\n. Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant:\n\n\n\n\n\n\n\n\nIns\u00e9rer le code suivant (de type Xpath) dans le \ncSetBody\n :\n\n\n\n\n  \ntns:HelloWorldServiceOperationRequest/in\n\n\n\n\n\nCeci permet de saisir le contenu de la balise \nin\n de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace \ntns\n (\nhttp://www.talend.org/service/\n).\n\n\n\n\nIns\u00e9rer le code suivant dans le processeur:\n\n\n\n\nString\n \nname\n \n=\n \nexchange\n.\ngetIn\n().\ngetBody\n(\nString\n.\nclass\n);\n\n\nString\n \nsurname\n;\n\n\nif\n \n(\nname\n.\ncontains\n(\nBob\n)){\n\n  \nsurname\n \n=\n \nBobby\n;\n\n\n}\nelse\n{\n\n  \nsurname\n \n=\n \nChucky\n;\n\n\n}\n\n\nexchange\n.\ngetIn\n().\nsetBody\n(\ntns:HelloWorldServiceOperationRequest \n+\n\n    \nxmlns:tns=\\\nhttp://www.talend.org/service/\\\nin\n\n    \n+\nsurname\n+\n/in\n \n/tns:HelloWorldServiceOperationRequest\n);\n\n\n\n\n\nCe code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom.\n\n\n\n\nModifier l'adresse du composant \ncCXF_1\n pour qu'il se lance sur le port 8043.\n\n\nSauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.\n\n\n\n\nFonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB\n\n\nFailover et R\u00e9partition de Charge\n\n\nService Locator\n\n\nVia le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).\n\n\nConfiguration du Service Locator\n\n\nPour activer le service locator (SL), il faut:\n\n\n\n\nD\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend\n\n\nActiver la prise en compte du SL au niveau du service cible\n\n\nConfigurer le consommateur du service pour prendre en compte le SL\n\n\n\n\n1. D\u00e9ploiement du SL dans le contenaire\n\n\nPour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB:\n\n\n  tesb:start-locator\n\n\n\n\nIl est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:\n\n\n\n\n2. Activer SL dans le service\n\n\nPour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio:\n\n\n\n\nClic-droit sur le service\n\n\nChoisir \nESB Runtime Options\n\n\nCocher la case \n\"Utiliser le Service Locator\"\n\n\n\n\nIl faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.\n\n\n3. Activer SL dans le consommateur\n\n\nAu niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case \nUse Service Locator\n.\n\n\nTest du Service Locator\n\n\nPour tester la r\u00e9partition de charges\n : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat.\n\n\nPour tester la gestion du failover\n : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper \nlist\n, puis chercher l'identifiant du service \nHelloWorldService\n. Taper ensuite : \nstop \nid_service>\n. Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.\n\n\nService Monitoring\n\n\nLe composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes.\n\n\nPour configurer le Service Activity Monitoring:\n\n\n\n\n\n\nD\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper :\n\ntesb:start-sam\n\n\n  Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services.\n\n\n\n\n\n\nActiver la prise en compte de SAM au niveau du service cible\n\n\n\n\nConfigurer le consommateur du service pour prendre en compte le SAM\n\n\n\n\nPour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que \nDb Visualizer\n.\n\n\nPour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants:\n\n\n\n\nDatabase connection configuration (Default)\n: Derby/JavaDB\n\n\nDriver\n: JavaDB/Derby Server\n\n\nDatabase Server\n: localhost\n\n\nDatabase Port\n: 1527\n\n\nDatabase\n: DB\n\n\nDB username\n: test\n\n\nDB password\n: test\n\n\n\n\nEx\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.\n\n\nAuthentification\n\n\nSecurity Token Service (STS) : Impl\u00e9mentation du WS-Trust\n\n\nDans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \n\"Trust\"\n veut dire \n\"Confiance\"\n: le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur.\n\n\nPour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service.\n\n\nLe STS (\nSecurity Token Service\n) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes:\n\n\n\n\nD\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s.\n\n\nV\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification\n\n\nRenouveler un jeton de s\u00e9curit\u00e9\n\n\nAnnuler un jeton de s\u00e9curit\u00e9\n\n\nTransformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent.\n\n\n\n\nL\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.\n\n\nConfiguration des Param\u00e8tres de S\u00e9curit\u00e9\n\n\nPour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes:\n\n\n\n\nD\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend\n\n\nConfigurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur\n\n\nActiver la prise en compte de STS dans votre service\n\n\nConfigurer votre client pour saisir les param\u00e8tres d\u2019authentification.\n\n\n\n\n1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution\n\n\nPour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal:\n\n    feature:install tesb-sts\n\n\n\nSi le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : \nlist\n. Vous devriez trouver les lignes suivantes:\n\n\n\n\n2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur\n\n\nComme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame.\n\n\nPour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: \nconteneur>/etc/users.properties\n.\n\n\nDans ce fichier, les informations d'authentification sont sous la forme: \nuser=password,group\n. Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe \nadmin\n.\n\n\n3. Activer STS dans votre service\n\n\nPour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans \nESB Runtime Options\n, cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, \nIdentifiant/Mot de passe\n)\n\n\n4. Configurer le client\n\n\nPour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.\n\n\nHomework\n\n\nReprendre l'application que vous avez cr\u00e9\u00e9 dans le Homework pr\u00e9c\u00e9dent (celle du processus de recrutement), en d\u00e9ployant cette fois votre service (REST ou SOAP) sur deux conteneurs ESB, en d\u00e9finissant au moins une route, et en activant les diff\u00e9rentes fonctionnalit\u00e9s suppl\u00e9mentaires (SL, SAM et STS).", 
            "title": "TP3"
        }, 
        {
            "location": "/tp3/#tp3-mise-en-place-dun-esb-avec-talend-esb", 
            "text": "", 
            "title": "TP3 - Mise en Place d\u2019un ESB avec Talend ESB"
        }, 
        {
            "location": "/tp3/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp3/#objectifs-du-tp", 
            "text": "Routage, m\u00e9diation et transformation avec Talend ESB.  Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp3/#outils-et-versions", 
            "text": "Talend Open Studio for ESB  Version: 6.3.0  Java  Version 1.8.0_121", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp3/#configuration-et-utilisation-de-lesb-talend", 
            "text": "", 
            "title": "Configuration et Utilisation de l'ESB Talend"
        }, 
        {
            "location": "/tp3/#lancement-de-deux-instances-de-lesb-talend", 
            "text": "Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire:   Aller dans le r\u00e9pertoire  rep_install_talend>/Runtime_ESBSE  Copier le r\u00e9pertoire  container  et le renommer en  alternate-container .   Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans  alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela:   Lancer l\u2019ESB  : dans le r\u00e9pertoire  alternate-container  que vous venez de cr\u00e9er, aller vers  bin  et ex\u00e9cuter  trun.bash  (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire  alternate-container/bin  et  lancer dans un terminal la commande  ./trun . La fen\u00eatre suivante devrait s\u2019afficher:     Attention  Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante.    Configurer l'ESB  : dans l\u2019invite de commande affich\u00e9e, taper:      source  scripts/configureC1.sh   Un affichage tel que le suivant va appara\u00eetre:    Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh.   Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau.  Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.", 
            "title": "Lancement de deux instances de l'ESB Talend"
        }, 
        {
            "location": "/tp3/#publier-votre-service-dans-lesb-et-le-tester", 
            "text": "Revenir au service web SOAP  HelloWorldService  que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur  Talend Open Studio  sur le projet  Helloworld , et suivre les \u00e9tapes suivantes:   Faire un clic-droit sur le service  HelloWorldService  et choisir  Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier  deploy  se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB).  D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9.  V\u00e9rifier que vos services sont actifs:  en tapant  list  dans vos deux instances d\u2019ESB  en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090.     Pour tester votre service web:   Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040  Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB.   V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:", 
            "title": "Publier votre Service dans l'ESB et le Tester"
        }, 
        {
            "location": "/tp3/#creation-des-routes", 
            "text": "Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.", 
            "title": "Cr\u00e9ation des Routes"
        }, 
        {
            "location": "/tp3/#premiere-route-filtrage-des-messages", 
            "text": "Cr\u00e9er une nouvelle route en cliquant-droit sur  Routes -  Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute.  D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit:      Les composants utilis\u00e9s sont:   cCXF  : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS.  MessageRouter \u00a0: route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es.     Configurer la condition  when , en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est :         ${bodyAs(String)} contains  Alice  \n  Cela veut dire que, si le corps du message contient  Alice , la requ\u00eate sera rout\u00e9e vers le composant  cCXF_2 .    Configurer le composant cCXF_1:   Adresse:  http://localhost:8042/services/HelloWorldService     WSDL:  http://localhost:8040/services/HelloWorldService?WSDL .      Remarque  Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB.    Configurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants.  Lancer la route pour la tester. La console devra afficher  connected .   Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous?", 
            "title": "Premi\u00e8re Route: Filtrage des Messages"
        }, 
        {
            "location": "/tp3/#deploiement-des-routes-sur-lesb", 
            "text": "Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes:   Faites un clic-droit sur votre route et s\u00e9lectionner:  Build Route  (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9).  Choisir le r\u00e9pertoire deploy du conteneur de votre choix.  Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur.    Attention  Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.", 
            "title": "D\u00e9ploiement des Routes sur l'ESB"
        }, 
        {
            "location": "/tp3/#deuxieme-route-filtrage-et-modification-de-messages", 
            "text": "Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela:   Dans Talend Studio, dupliquer votre route  FiltrageRoute  et la nommer  ModificationRoute .  Ins\u00e9rer un composant  cSetBody  (permettant de modifier le corps du message re\u00e7u) puis un composant  cProcessor  (permettant  de remanier rapidement du code dans la route) entre le  cMessageRouter  et le  cCXF_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant:     Ins\u00e9rer le code suivant (de type Xpath) dans le  cSetBody  :      tns:HelloWorldServiceOperationRequest/in   Ceci permet de saisir le contenu de la balise  in  de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace  tns  ( http://www.talend.org/service/ ).   Ins\u00e9rer le code suivant dans le processeur:   String   name   =   exchange . getIn (). getBody ( String . class );  String   surname ;  if   ( name . contains ( Bob )){ \n   surname   =   Bobby ;  } else { \n   surname   =   Chucky ;  }  exchange . getIn (). setBody ( tns:HelloWorldServiceOperationRequest  + \n     xmlns:tns=\\ http://www.talend.org/service/\\ in \n     + surname + /in   /tns:HelloWorldServiceOperationRequest );   Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom.   Modifier l'adresse du composant  cCXF_1  pour qu'il se lance sur le port 8043.  Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.", 
            "title": "Deuxi\u00e8me Route : Filtrage et Modification de Messages"
        }, 
        {
            "location": "/tp3/#fonctionnalites-supplementaires-de-lesb", 
            "text": "", 
            "title": "Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB"
        }, 
        {
            "location": "/tp3/#failover-et-repartition-de-charge", 
            "text": "", 
            "title": "Failover et R\u00e9partition de Charge"
        }, 
        {
            "location": "/tp3/#service-locator", 
            "text": "Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).", 
            "title": "Service Locator"
        }, 
        {
            "location": "/tp3/#configuration-du-service-locator", 
            "text": "Pour activer le service locator (SL), il faut:   D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend  Activer la prise en compte du SL au niveau du service cible  Configurer le consommateur du service pour prendre en compte le SL", 
            "title": "Configuration du Service Locator"
        }, 
        {
            "location": "/tp3/#1-deploiement-du-sl-dans-le-contenaire", 
            "text": "Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB:    tesb:start-locator  Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:", 
            "title": "1. D\u00e9ploiement du SL dans le contenaire"
        }, 
        {
            "location": "/tp3/#2-activer-sl-dans-le-service", 
            "text": "Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio:   Clic-droit sur le service  Choisir  ESB Runtime Options  Cocher la case  \"Utiliser le Service Locator\"   Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.", 
            "title": "2. Activer SL dans le service"
        }, 
        {
            "location": "/tp3/#3-activer-sl-dans-le-consommateur", 
            "text": "Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case  Use Service Locator .", 
            "title": "3. Activer SL dans le consommateur"
        }, 
        {
            "location": "/tp3/#test-du-service-locator", 
            "text": "Pour tester la r\u00e9partition de charges  : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat.  Pour tester la gestion du failover  : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper  list , puis chercher l'identifiant du service  HelloWorldService . Taper ensuite :  stop  id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.", 
            "title": "Test du Service Locator"
        }, 
        {
            "location": "/tp3/#service-monitoring", 
            "text": "Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes.  Pour configurer le Service Activity Monitoring:    D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper : tesb:start-sam \n  Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services.    Activer la prise en compte de SAM au niveau du service cible   Configurer le consommateur du service pour prendre en compte le SAM   Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que  Db Visualizer .  Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants:   Database connection configuration (Default) : Derby/JavaDB  Driver : JavaDB/Derby Server  Database Server : localhost  Database Port : 1527  Database : DB  DB username : test  DB password : test   Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.", 
            "title": "Service Monitoring"
        }, 
        {
            "location": "/tp3/#authentification", 
            "text": "", 
            "title": "Authentification"
        }, 
        {
            "location": "/tp3/#security-token-service-sts-implementation-du-ws-trust", 
            "text": "Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust.  \"Trust\"  veut dire  \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur.  Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service.  Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes:   D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s.  V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification  Renouveler un jeton de s\u00e9curit\u00e9  Annuler un jeton de s\u00e9curit\u00e9  Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent.   L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.", 
            "title": "Security Token Service (STS) : Impl\u00e9mentation du WS-Trust"
        }, 
        {
            "location": "/tp3/#configuration-des-parametres-de-securite", 
            "text": "Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes:   D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend  Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur  Activer la prise en compte de STS dans votre service  Configurer votre client pour saisir les param\u00e8tres d\u2019authentification.", 
            "title": "Configuration des Param\u00e8tres de S\u00e9curit\u00e9"
        }, 
        {
            "location": "/tp3/#1-deployer-sts-dans-le-conteneur-dexecution", 
            "text": "Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal:     feature:install tesb-sts  Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande :  list . Vous devriez trouver les lignes suivantes:", 
            "title": "1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution"
        }, 
        {
            "location": "/tp3/#2-configurer-les-parametres-de-securite-de-votre-conteneur", 
            "text": "Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame.  Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier:  conteneur>/etc/users.properties .  Dans ce fichier, les informations d'authentification sont sous la forme:  user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe  admin .", 
            "title": "2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur"
        }, 
        {
            "location": "/tp3/#3-activer-sts-dans-votre-service", 
            "text": "Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans  ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas,  Identifiant/Mot de passe )", 
            "title": "3. Activer STS dans votre service"
        }, 
        {
            "location": "/tp3/#4-configurer-le-client", 
            "text": "Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.", 
            "title": "4. Configurer le client"
        }, 
        {
            "location": "/tp3/#homework", 
            "text": "Reprendre l'application que vous avez cr\u00e9\u00e9 dans le Homework pr\u00e9c\u00e9dent (celle du processus de recrutement), en d\u00e9ployant cette fois votre service (REST ou SOAP) sur deux conteneurs ESB, en d\u00e9finissant au moins une route, et en activant les diff\u00e9rentes fonctionnalit\u00e9s suppl\u00e9mentaires (SL, SAM et STS).", 
            "title": "Homework"
        }, 
        {
            "location": "/tp4/", 
            "text": "TP4 - Microservices", 
            "title": "TP4"
        }, 
        {
            "location": "/tp4/#tp4-microservices", 
            "text": "", 
            "title": "TP4 - Microservices"
        }, 
        {
            "location": "/tp5/", 
            "text": "TP5 - API Management avec Atom et Anypoint", 
            "title": "TP5"
        }, 
        {
            "location": "/tp5/#tp5-api-management-avec-atom-et-anypoint", 
            "text": "", 
            "title": "TP5 - API Management avec Atom et Anypoint"
        }
    ]
}